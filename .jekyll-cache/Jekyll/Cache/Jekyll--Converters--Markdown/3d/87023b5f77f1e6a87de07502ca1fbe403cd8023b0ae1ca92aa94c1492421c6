I")<blockquote>
  <p>摘自「Pro Git」<br />
仅用于本人理解和查阅。不全之处，日后补充。</p>
</blockquote>

<h3 id="git分支">Git分支</h3>

<p>Git每次提交可以简单理解为创建一个当前提交文件的快照，并且当前的提交对象包含一个指向上次提交对象的指针。</p>

<blockquote>
  <p>Git分支实质上是包含所指对象校验和（长度为40的SHA-1值字符串）的文件</p>
</blockquote>

<p>Q：提交记录多了之后，每个版本的快照会不会占用很多空间？</p>

<p>Q：那么每个版本的文件快照（提交对象）是什么东西？<br />
A：每次提交的确会产生一个新的提交对象，但是单纯创建分支并没有产生提交。当你从新分支的新版本回滚时，是将新的提交对象替换为了旧版本的提交对象。</p>

<h3 id="忽略文件">忽略文件</h3>

<p>可在git仓库目录中的<code class="highlighter-rouge">.gitignore</code>文件中，设置忽略的文件，如</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>*.[oa]
*~
</pre></td></tr></tbody></table></code></pre></div></div>

<p>将会忽略所有以<code class="highlighter-rouge">.o</code>或<code class="highlighter-rouge">.a</code>以及<code class="highlighter-rouge">~</code>结尾的文件。</p>

<p>格式规范如下：</p>

<ul>
  <li>忽略所有空行和以<code class="highlighter-rouge">#</code>开头的行</li>
  <li>可以使用标准的glob模式（简化的正则表达式）匹配</li>
  <li>模式匹配可以以<code class="highlighter-rouge">/</code>开头防止递归</li>
  <li>可以以<code class="highlighter-rouge">/</code>结尾指定目录</li>
  <li>可以在模式前加<code class="highlighter-rouge">!</code>取反</li>
</ul>

<p><code class="highlighter-rouge">*</code>匹配0个或任意个字符;<br />
<code class="highlighter-rouge">[abc]</code>匹配方括号中的一个字符;<br />
<code class="highlighter-rouge">[0-9]</code>使用短划线分割两个字符则匹配两个字符范围内的任意字符(一个);<br />
使用两个星号<code class="highlighter-rouge">**</code>匹配任意中间目录, 如<code class="highlighter-rouge">a//**/z</code>可以匹配<code class="highlighter-rouge">a/z</code>, <code class="highlighter-rouge">a/b/z</code>或<code class="highlighter-rouge">a/b/c/z</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>    # ignore all files in the build/ directory
    build/

    # ignore doc/notes.txt, but not doc/server/arch.txt
    doc/*.txt

    # ignore all .pdf files in the doc/ directory
    doc/**/*.pdf
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="git-head指针">Git HEAD指针</h3>

<p>HEAD^  ==&gt; HEAD的父指针<br />
HEAD~2  ==&gt; HEAD的祖父指针，相当于HEAD^^、<br />
HEAD^2 ==&gt; HEAD的第二父提交，只在合并分支的提交中可以使用（因为有不止一个父提交，第一父提交是合并时所在的分支，第二父提交是合并进来的分支）</p>

<h3 id="command">Command</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">git diff</code></p>

    <p>显示尚未暂存的改动与暂存区文件快照之间的差别</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">git rm</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>  # 不加参数时，从暂存区和工作区移除文件。

  --cached    # 仅从暂存区移除，在工作区保留
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git mv</code></p>

    <p>文件改名</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>  git mv oldName.md newName.md
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git log</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>  -p      # 显示每次提交的内容差异
  -2      # 显示最近两条提交记录
  --since=2.weeks  
  --since="2019-10-01"
  -S      # 显示添加或者移除了某些特殊字符串的提交
  -Sfunction_name     # 查找添加/移除了"function_name"的提交
  --pretty # =oneline # =format:"%h "
  --oneline

  *--*----*---*---master
      \
       ----*---*---exp

  master..exp     # 查看在exp分支而不在master分支中的提交
    
  # 在分支引用前加^或--not指明不希望包含在内的分支，因此上式等价于
  exp ^master # 或 exp --not master

  --left-right master...exp       
  # 被master和exp其中一个包含但不是二者共有的提交
  # --left-right将标识该提交属于左/右（master/exp）
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git checkout</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  git checkout -- &lt;filename&gt; 
  # 用某次提交的文件来覆盖暂存区和工作区的文件，所以会丢失工作区中的修改，请慎重使用此命令

  -b &lt;branch name&gt;
  # 创建并将HEAD移动到一个新分支
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git commit</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>  --amend   
  # 将修改合并到上一次commit中，类似做了rebase操作，会修改SHA-1的校验和
  #（所以如果push到远端了就不要使用。why？远程仓库不能一起修改吗）
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git remote</code></p>

    <p>https<br />
  git://<br />
  git@github</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">git fetch</code></p>

    <p>从远程仓库拉取数据，但是并不合并。合并使用<code class="highlighter-rouge">pull</code>。</p>

    <blockquote>
      <p>p80: 抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本，只有一个不可修改的指针</p>
    </blockquote>

    <p>Q:到底抓取了什么东西下来？</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">git stash</code></p>

    <p>暂存未完成并且不想提交的改动</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>  git stash / git stash save      # 暂存

  git stash list    
  # 查看栈中的暂存

  git stash apply ( stash@{2} )  
  # 不指定则默认为0

  git stash pop   
  # 应用暂存，然后丢弃

  git stash drop ( stash@{2} )    
  # 丢弃指定的暂存
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git reset</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  --soft
  # 只移动HEAD指针

  --mixed     
  # 移动HEAD指针，并且回滚暂存区。因此会回到那次提交之前的状态（如果之后你对工作区有改动的话）

  --hard
  --merge     
  # 移动HEAD指针，并且改变暂存区和工作区
  # 目前需要的回滚通常要改变工作区，所以这两个选项会用的比较多
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">git checkout</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  git checkout [branch]
  # 类似git reset --hard [branch], 但是会尝试合并修改(?)，并且不会移动分支的指针

  git checkout [branch] filename
  # 类似git reset --hard，不移动HEAD指针，修改暂存区，不同的是会覆盖工作区中的文件
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>回想一下，<code class="highlighter-rouge">git reset --mixed</code>移动HEAD指针, 但是同样我们也可以用<code class="highlighter-rouge">--soft</code>把HEAD移动到想要的位置.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">git push</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>  -f
  --force
  # 

  --force-with-lease
  # 
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h3 id="跟踪分支">跟踪分支</h3>

<p>在跟踪分支上运行<code class="highlighter-rouge">git pull</code>能够自动抓取上游分支（upstream）并且合并到当前的跟踪分支。</p>

<p>可以使用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>git checkout --track origin/serverfix   
# 将serverfix设为跟踪分支

git checkout -b sf origin/serverfix     
# 将sf设为跟踪分支


git branch -u/--set-upstream-to 
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="merge-rebase">merge, rebase</h3>

:ET