---
layout: post
title: "[]"
subtitle: 
author: "Dongbo"
header-style: text
mathjax: true
hidden: false
tags:
  - 
---

> 总结传统的 view selection 方法如何对物化视图的增益进行评估。

1. 1997 MVPP 的两篇
同样只给出了代价的定义（记号），而没给出工程上实际计算的方法。
都tm手工给老子算的增益和选择哪个节点，气死老子了（考虑看一下修改一下MVPP那部分的综述

2. 1997 selection of views （考虑更新开销）
评估增益，只给出定义： 
  对于某个视图集合 C，其增益为 不使用C时的开销，减去M（如果原本已经选择有视图的话，没有就是空集）并上 C之后的开销。 
  那么具体如何获得呢？ 没有提到，只给出了一个单调性的说明；
这个贪心还是没有提到如何具体计算得到增益啊？直接给出 Benefit 的定义，然后就给出算法了。

3. 1998 的 under view maintainance 也是类似，仅给出定义

4. 2000 automated selection for mv & index（包含了实践/实验的，但是同样没有具体说
(只在TPC-H中很少的query) 奥，倒也不止，也在其他稍微大一些的（几十到一百）benchmark上试验过
不过具体如何计算 一个 mv 候选的开销？也是只给了定义？
//（奥，SQL Server 的优化器可以考虑 mv 进行查询重写；mv 在SQL Server里叫索引视图。

对每个query，从它对应的 mv 集合中，通过优化器找到能使该查询 代价最低的，作为 候选
留了个接口，说任意可以获取最低 cost 的函数都适用，比如Greedy(m, k)；
// 想一想到底如何具体计算的？  也只是给了个算法，具体操作方法呢？ 
具体获取增益/mv代价的方式也没有提及

为了与穷举搜索方法进行比较，limits our experiments to relatively small workloads

比起穷举，这里的贪心明显快（运行用时为穷举的10%左右），算法质量没有大幅下降（降低20%）

同时我们并不知道该工作到底如何进行mv的代价估计的。（考虑到workload规模很小，候选的数量并不多（不超过200）），似乎可以通过手工创建和重写查询完成。

5. 2009 分布式 遗传算法 mv 
感觉没有提如何估算cost啊？ 
遗传算法终止的部分，只是说 “当cost不再减少的轮次达到一定数额时终止”，到底如何估算cost呢？优化器？优化器如何考虑mv呢？不需要人工介入吗？

java 模拟的分布式环境，对于优化器进行了修改（也有可能是自己写的优化器），所以他们的优化器会在每一个 intermediate result 考虑能够通过 mv 计算得到，并且定义了自己优化器的代价模型（考虑分布式的传输开销）




-------------------
关于查询重写：

oracle的查询重写，论文：1998 mv in oracle
但是其中的查询重写部分没有看懂

SQL Server同样实现了查询重写，会考虑索引视图进行查询优化，要求索引视图具备聚类索引，并且查询的列是索引视图的子集；然而具体如何实现，是个问题。。。

postgres的查询重写，基于规则，定义对某个动作（select/update/delete)用另一个动作代替；
这里的规则有 ev_qual 作为筛选，类型有INSTEAD和ALSO
https://blog.csdn.net/weixin_47373497/article/details/121169359
但是似乎并不会针对物化视图进行查询重写



