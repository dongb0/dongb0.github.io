---
layout: post
title: "[]"
subtitle: 
author: "Dongbo"
header-style: text
mathjax: true
hidden: false
tags:
  - 
---


abstract

对于使用 common/similar subexpression的查询优化问题
第一个 comprehensive 解决方法：从检测、构建、到基于开销的优化，
在 SQL server 上实现


1 Intro 

优化器的优化目标只是单条 SQL，而不会考虑全局最佳的执行计划；


SQL 中可以有两种方式供 用户表示 sharable subexpr：1）虚拟视图；2）WITH子句定义的表
但是简单的直接物化这些 subexpr 并不是最佳选择


2 System Architecture
transformation-based optimizer

2.1 Optimizer Overview
优化器应用 local transformation rules 生成 expr

2.2 Solution Overview

Step 1：通过每个查询的 table signature 来检测 CSE？ signature 不同的 expr 则无法通过 CSE 计算得到


Step 2：Generation of candidate CSEs
优化器查找来自查询不同部分（如不同op？）但具有相同 signature 的 expr 作为潜在候选
然后根据它们来生成候选 CSE

（会物化的

Step 3：Optimization with candidate CSEs；将 CSE 看作物化视图，供优化器用来重写查询计划；（但是这些数据实际需要物化吗
优化器也可以选择不使用 CSE


3 Table Signature

definition：Table Signature
SPJG 表达式才有，然后包括两部分
1 G：bool,表示是否包含 group by
2 T：source table 列表

可以用来快速的检测两个表达式 能否用 同一个 CSE 覆盖（计算得到）

4 Generating Candidate CSEs
Covering SubExpression(CSE)

如果对相同 signature 的 expr 做笛卡尔积，那么确实可以覆盖所有可能的表达式，但是这显然不现实；

这一节介绍如何生成“可靠的” CSE 供优化器选择

4.1 Join Compatible Expressions

指，包括足够多的公共 JOIN 操作

定义一个  Join Compatible 概念
大概理解上来说感觉是两个相同的表，在不完全相同的 column 上 join，但是有部分（至少一个） join 条件是相同的

4.2 Covering Subexpression

将相同 table signature 的 expr 按照 join compatible 分好组之后，对每个 group 我们可以生成 CSE 来覆盖该组内 expr 所有可能需要的输出

非公共的部分做一个 析取（OR）

公共部分保留，做合取（AND）

4.3 Candidate Generation

贪心！
从 trivial CSE 开始，每次贪心合并一个 max merging benefit 的 直到没有为止

