---
layout: post
title: "[]"
subtitle: 
author: "Dongbo"
header-style: text
mathjax: true
hidden: false
tags:
  - paper
---

Q0：aggregation lattice 是什么? // 文献 \[10] 的用词，实际上是一个 DAG，但是具体每个节点的含义是？  大概看一下： Implementing Data Cubes Efficiently. 25页，没法全看完

Q1：索引选择的问题中，有动态索引选择的方法吗?分布式场景下的呢?


abstract 
物化视图在数据仓库中的应用：选择最优的聚合视图集合，重写查询来利用 summary，修改基础表时同步预计算的 summary 数据。

本文提出了一种在分布式数据仓库中应用的贪心视图选择算法，adequate cost model；并与在每个节点上单独应用选择算法的效果作了对比。


introduction

背景略，本文研究的问题是：在存储限制和维护开销的限制下，选择最优的物化聚合视图来加速查询。

sec 2 related work
sec 3 aggregation lattice 
sec 4 cost model within distributed scenario
sec 5 the algorithm
sec 6 performance
sec 7 summary

2 Related Work
视图选择算法分类：

静态选择算法：基于给定的用户查询（后面也叫workload），和时间空间限制，来选择一组物化视图；
1）子问题是限制最大可用存储空间开销，如
\[10,7，4]的研究？considering indices，基于 maximum benefit per unit space 的贪心算法；
\[15]的根据 view size 重新排序的选择过程等

2）第二类子问题限制视图的维护开销（much harder to solve，因为考虑维护开销的 benefit function 不是单调），
\[8]提出了一种在这种（不单调）的情景下也健壮的贪心算法

3）第三类子问题是 multiple view processing plan？，并且应用在多查询优化上？ \[14]
思想是构造一个reasonably good overall查询计划？////??? \[16] 

第二大类是动态选择算法 \[5,13,11]

3 Problem Space of the Distributed View Selection Process

3.1 Basic Prerequisites
可推导理论？ 在什么条件下，一个查询 Q 能够使用等价的物化视图来响应（answered）

定义1： 视图
view v 是一组属性（attribute）{G1,...,Gn}的集合
不同粒度的视图构成篇序关系，表示视图可以通过其他视图计算得到

定义2：可推导性（Derivability）
视图 V2 （粒度Gv2，位于 Nv2节点）能够由视图 V1 （粒度Gv1,位于Nv1）推导得到，需要满足：
- Nv1 Nv2之间存在可交换边 
- v1 的粒度更细，即 v1 大于等于 v2 包含的属性

所有的视图都可以根据 grouping 的属性，按照他们的推导关系来组织成有向无环图（DAG），
\[10, 6]，图中节点表示 single grouping combination（视图？关系？），边表示有向的推导关系

3.2 Distributed Aggregation Lattice
聚合网格（aggregation lattice） // 似乎是一个集中式算法就已经研究比较多的概念？ 

// 单纯follow 某一篇文章的工作罢了

除了原本的聚合依赖边意外，
要在图中加入表示通信开销的边（分布式网络中面对的问题），但这样会在图中引入环。论文中的方法将这些边扩展为二分子图，//？

考虑 3 副本的分布式数据仓库，可以将原本的 aggregation lattice 中的一个节点分裂为 3 个，这三个对等的节点构成一个子图，他们之间是全连接的。

基础表放在哪个节点上?
论文通过引入一个虚拟的“基础节点”，当作 data provider，持有完整的数据并且将数据分发到整个数据仓库中。基础节点与实际节点之间的通信开销出时设为无穷大，这会导致视图选择算法的 allocation / replication ///？？？

同样引入一个 top node，to close the lattice with a single node ///？？？



定义3：分布式聚合网格(Distributed Aggregation Lattice)
节点分为两类 v1 定义为 s-node，v2 定义为 t-node

网格中不同粒度的节点之间的边，表示计算开销，s-node t-node 之间的边（相同粒度），表示传输数据的通信开销；

对于原本没有直接连接的两个节点，可以将中转连接的开销，记为两个节点之间的传输开销（加上一条边），最后把所有的节点建立成全连接的。


4 Cost Model

我们假设通信开销和使用视图后的查询开销这两个代价函数与 视图的维度（cardinality）和 视图size 之间是独立的，最后定义得到单个查询的代价公式 + 总 workload 的代价公式

再次重申视图选择问题的计算复杂度是 NP-hrad \[9]
近似算法通常采用贪心，算法每一步通过 benefit function 来决定选择那些视图

使用视图 V={v1,...,vn} 的 benefit B 表示为 物化这些视图之后，能够使整体查询执行开销降低的幅度。

\[8] 中说明，如果代价函数不是单调的，贪心算法每一步只考虑一个视图可能会导致 bad solution。
通常来说如果考虑视图析取后的增益小于 每个视图带来的增益之和，那么 B 是单调的； （但是事实上好像并非如此？）


// Q：也就是说，如果不考虑视图维护开销的话，代价模型就是单调的了？
4.1 A Monitonic Cost Model
benefit 考虑的是 per space unit；（否则就用一个超踏马大的视图了）

线性的代价模型，用不使用视图V={v1,...,vk}的开销，减去使用V的开销，得到的差除以这部分视图的空间站用；（公式不贴图了，原文有

满足上文提到的单调性；同时视图的 size 也是单调增加的。


4.2 A Non-Monotonic Cost Model
如果考虑更新视图的时间限制，或者节点之间的传输开销的话，反映在代价函数上就会导致代价函数不是单调的了；

------------------------
原因：
独立更新多个视图可能比一次更新一个更大的视图，需要更多时间； 更多关于代价函数非单调的介绍参考文献 \[8]
------------------------
文献 \[8]

5 Distributed View Selection Algorithm

定义 4： Distributed View Selection Problem

workload Q = {q1,...,qn}, 每个查询对应频率 {f1,...,fn}，设Sni为节点i可用于物化视图的存储空间，视图选择的 solution 是一组视图的集合 M = {v1,...,vn} 且 对j求和|Vjni| <= Sni （即存储在节点i上的视图不超过 Sni），能够使所有查询的代价总和 C(Q,M) = 对i求和 fi*C(qi, M)最小；

文中使用的 增益函数 per unit space 是单调的，只与被评估的视图相关。

文献\[8,9,10]提到基于贪心的算法得到的 solution 至少为 最优解 的 (63-x)%，x是最大的候选视图与左右存储空间的比值
// TODO：是否应该去读这些文献？

如果增益函数是单调的，那么就能满足该估算的下界？ // ？

在分布式场景下，每个节点的存储空间是独立的，因此下界不能保证？n个节点将带来n维的空间约束，从而变成多重背包问题，使下界无法保证。

5.1 Distributed Node Set Greedy
文中提出的贪心算法与单节点上应用的贪心算法主要的区别是（sec 3 已经介绍过了？咋的我没印象？）

算法接收分布式聚合网格和每个节点的存储空间作为输入，然后根据基础表初始化一组视图。只要存储空间还有剩余就会选择当前配置中收益最高的作为 solution 集合中的物化视图；

网格中没被选择的节点会被用于计算收益（B{v},M）（这也来自于 descendant nodes），一次迭代之后收益最高的节点加入 候选。另外为了解决不同节点上出现同样增益的情况，论文采用了这样的策略：选择剩余空间最多的节点。 这并不能保证最优


单节点运行贪心算法的复杂度为 O(mk^2)，m是最后物化视图的数量，k是聚合网格节点的数量。
分布式场景下，算法的复杂度变为 O(nmk^2)，其中 n 是数据仓库节点的数量。

文献\[4] 对网格有化简？

为了改进贪心算法每次只根据当前 configuration 来进行决策，可以扩展为 “多看一步” 的贪心。// 感觉本质没有变啊 // 每次迭代时考虑 i th 和 i + 1 th 的视图 并选择其中收益最高的视图组合。复杂度将提升为 O(m (nk)^3)，但能够忽略潜在的 dicisions// 可能是算法里某些处理条件；

另一种方法是穷举 size 为 q 的子集。在计算增益时就构造所有 q 个元素的子集，并选择其中收益最高的作为贪心算法的初始输入，并且在剩下的视图中搜索直到用完剩余的空间。

还有一些其他的优化，但算法的本质并不改变，但相对来说减少了选择 bad solution 的概率。

5.2 Example of the Local vs Distributed View Selction

模拟3节点的数据仓库，假设计算开销和通信开销都相等（此处设为w=1），workload 假设均衡分配在所有节点上，所有查询的出现频率都设为1；每个节点的存储空间限制 Sni = 120，基础表初始放在在节点N。


// 每轮就选 benefit per unit space 最高的节点，一直到用完存储空间为止。但是不考虑传输开销啊，也假设节点都是对等的。 //

// total query costs 的计算为什么是 只从物化的几个节点就能满足所有查询了？
// 所以甚至 分布式场景 的查询响应开销还比集中式的小了？



6 Performance Studies
在略微复杂的环境下（随机产生query，不同频率）对比集中式和分布式的算法；

a）发现随着节点数量增多，分布式算法的性能增益会逐渐提升（感觉不符合实际场景啊，通信开销只计算了几乎可以忽略的一小部分）；不过文中解释说，如果一个视图可以从 peer 获取，那么本地空间就可以用来物化其他 收益 更高的视图，因此在（几乎忽略）通信开销的情况下有提升是很正常的。（实际应用场景中也许对应的是同一个机房内部署的机架？

b）对比不同的 weight factor 下算法的性能（weight factor 是计算开销和通信开销 (比值？)),
通信开销越大，分布式算法的增益就越小

c）query set 越小，分布式算法的增益越高（比起集中式

d）空间限制越大，分布式算法的收益逐渐降低到接近集中式算法的水平，因为集中式算法也可以物化足够多的视图

7 Summary

提出的分布式视图选择算法（贪心算法）在模拟的分布式数据仓库环境下，比起在每个节点上应用集中式视图选择算法，带来了一定的性能增益（在文中假设的环境下降低15%的开销）

还可以再看看。



我的总结：这篇文章把一种用于集中式系统的视图选择算法扩展到分布式环境下，但是仅仅考虑了空间占用的限制（而没有考虑视图维护开销限制）